# 零 dll工程

创建一个dll工程，其他文件都删掉，只留一个dllmain.cpp，且属性里面不使用预编译头

![1](./../../操作/9Inject/1.jpg)

DLL

```cpp
// dllmain.cpp : 定义 DLL 应用程序的入口点。
#include <iostream>
#include <windows.h>

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    // 当前DLL被其他进程加载的时候，执行这段代码
    case DLL_PROCESS_ATTACH:
    {
        char szBuff[0x256] = { 0 };
        sprintf_s(szBuff, "%x", hModule);

        MessageBoxA(0, szBuff, 0, 0);
        break;
    }
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
```

Win32

```cpp
#include <iostream>
#include <windows.h>

int main()
{
    HMODULE hModule = LoadLibraryA("..\\Inject\\Debug\\Inject.dll");
    system("pause");
}
```

# 一 注入的本质

![2](./../../操作/9Inject/2.jpg)

注入的本质。将一个dll，拉伸，修复之后，贴到另一个进程中

# 二 同一台电脑上。不同进程的系统dll的线性地址是一样的

![3](./../../操作/9Inject/3.jpg)

因为这些系统DLL用的非常多，所以同一个系统的这些系统DLL都映射到一份物理页

就是共享内存，有写拷贝。如果没有写拷贝，如果HOOK错了之后，操作系统也炸了

![4](./../../操作/9Inject/4.jpg)

不同进程的系统dll的虚拟内存地址也是一样的。同一台电脑上。

![5](./../../操作/9Inject/5.jpg)

同一台电脑上。不同进程的Kernel32.dll的线性地址是一样的，所以LoadLibrary的线性地址也是一样的

# 三 远程线程注入

远程线程注入

两个进程的LoadLibrary的地址是一样的，但是LoadLibrary的参数字符串的地址不一样。需要跨进程申请空间，将LoadLibrary的参数字符串也就是要注入的dll路径贴到目标进程中

```cpp
#include <iostream>
#include <windows.h>

CHAR szBuffer[] = "C:\\Users\\Administrator\\Documents\\BaiduSyncdisk\\1Learning\\Reverse\\FerryCofc\\1Game\\Code\\9Inject\\Inject\\Debug\\Inject.dll";

void RemoteThreadInject(DWORD dwPid, PCHAR szDllPath)
{
    HANDLE hProcess = 0;
    LPVOID pDllPath = 0;
    DWORD dwDllPathSize = 0;

    BOOL bRet = 0;

    HMODULE hModuleKernel32 = 0;
    DWORD dwFunAddr = 0;

    HANDLE hThread;

    // 打开目标进程，得到指定注入进程句柄
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);
    if (hProcess == NULL)
    {
        printf("OpenProcess Error -> [%x] \r\n", GetLastError());
        return;
    }

    dwDllPathSize = strlen(szDllPath) + 1;
    // 在指定进程中申请内存，存储LoadLibrary的参数(dll的路径)
    pDllPath = VirtualAllocEx(hProcess, NULL, dwDllPathSize, MEM_COMMIT, PAGE_READWRITE);
    if (!pDllPath)
    {
        printf("VirtualAllocEx Error -> [%x]\r\n", GetLastError());
        return;
    }

    // 目标进程中，将Dll路径写入到分配的内存当中
    bRet = WriteProcessMemory(hProcess, pDllPath, szDllPath, dwDllPathSize, NULL);
    if (!bRet)
    {
        printf("WriteProcessMemory Error -> [%x]\r\n", GetLastError());
        return;
    }

    // CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, pDllPath, 0, NULL);

    // 获取本机LoadLibraryA地址
    hModuleKernel32 = LoadLibraryA("Kernel32.dll");
    if (!hModuleKernel32)
    {
        printf("LoadLibraryA Error -> [%x]\r\n", GetLastError());
        return;
    }
    dwFunAddr = (DWORD)GetProcAddress(hModuleKernel32, "LoadLibraryA");

    // 创建远程线程。线程过程函数是LoadLibrary加载我们注入了的的dll路径
    hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)dwFunAddr, pDllPath, 0, NULL);
    if (!hThread)
    {
        printf("CreateRemoteThread Error -> [%x]\r\n", GetLastError());
        return;
    }
}

int main()
{
    RemoteThreadInject(38408, szBuffer);
}
```

![6](./../../操作/9Inject/6.jpg)

# 四 远程卸载注入过的dll

远程卸载我们注入过的dll

```CPP
#include <iostream>
#include <windows.h>

#include <TlHelp32.h>

// PETool 1.0.0.5.exe
CHAR szBuffer[] = "C:\\Users\\Administrator\\Documents\\BaiduSyncdisk\\1Learning\\Reverse\\FerryCofc\\1Game\\Code\\9Inject\\Inject\\Debug\\Inject.dll";

void RemoteThreadInject(DWORD dwPid, PCHAR szDllPath)
{
    HANDLE hProcess = 0;
    LPVOID pDllPath = 0;
    DWORD dwDllPathSize = 0;
    BOOL bRet = 0;

    HMODULE hModuleKernel32 = 0;
    DWORD dwFunAddr = 0;

    HANDLE hThread;

    // 打开进程，得到指定注入进程句柄
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);
    if (hProcess == NULL)
    {
        printf("OpenProcess Error -> [%x] \r\n", GetLastError());
        return;
    }

    dwDllPathSize = strlen(szDllPath) + 1;
    // 在指定进程中申请内存，存储LoadLibrary的参数(dll的路径)
    pDllPath = VirtualAllocEx(hProcess, NULL, dwDllPathSize, MEM_COMMIT, PAGE_READWRITE);
    if (!pDllPath)
    {
        printf("VirtualAllocEx Error -> [%x]\r\n", GetLastError());
        return;
    }

    // 目标进程中，将Dll路径写入到分配的内存当中
    bRet = WriteProcessMemory(hProcess, pDllPath, szDllPath, dwDllPathSize, NULL);
    if (!bRet)
    {
        printf("WriteProcessMemory Error -> [%x]\r\n", GetLastError());
        return;
    }

    // CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, pDllPath, 0, NULL);

    // 获取LoadLibraryA
    hModuleKernel32 = LoadLibraryA("Kernel32.dll");
    if (!hModuleKernel32)
    {
        printf("LoadLibraryA Error -> [%x]\r\n", GetLastError());
        return;
    }
    dwFunAddr = (DWORD)GetProcAddress(hModuleKernel32, "LoadLibraryA");

    // 创建远程线程。线程过程函数是LoadLibrary加载我们的dll
    hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)dwFunAddr, pDllPath, 0, NULL);
    if (!hThread)
    {
        printf("CreateRemoteThread Error -> [%x]\r\n", GetLastError());
        return;
    }
}

// 通过进程名获取进程ID
DWORD GetProcessIdByName(PWCHAR ProcessName)
{
    // 创建进程快照
    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnap == INVALID_HANDLE_VALUE)
    {
        return 0;
    }

    // 创建进程信息结构体
    PROCESSENTRY32 pe32 = { 0 };
    pe32.dwSize = sizeof(pe32);

    // 遍历进程
    if (Process32First(hSnap, &pe32))
    {
        do 
        {
            // wprintf_s(TEXT("%s\r\n"), pe32.szExeFile);
            if (wcscmp(pe32.szExeFile, ProcessName) == 0)
            {
                return pe32.th32ProcessID;
            }

        } while (Process32Next(hSnap, &pe32));
    }
}

BOOL FreeInjectDll(DWORD dwPid, PWCHAR DllName)
{
    // 拍摄指定进程中所有模块的快照
    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPid);
    if (hSnap == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    // 初始化模块结构体
    MODULEENTRY32 me32 = { 0 };
    me32.dwSize = sizeof(me32);

    // 遍历目标进程的所有模块
    if (Module32First(hSnap, &me32))
    {
        do 
        {
            // wprintf_s(TEXT("%s \r\n"), me32.szModule);
            // 如果目标进程的模块中存在我们注入的模块
            if (wcscmp(me32.szModule, DllName) == 0)
            {
                // 打开进程。获取目标进程句柄
                HANDLE hProecss = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);
                if (hProecss == NULL)
                {
                    return FALSE;
                }

                // 获取FreeLibrary的地址
                HMODULE hModuleKernel32 = LoadLibraryA("Kernel32.dll");
                if (!hModuleKernel32)
                {
                    return FALSE;
                }
                DWORD dwFunAddr = (DWORD)GetProcAddress(hModuleKernel32, "FreeLibrary");
                if (!dwFunAddr)
                {
                    return FALSE;
                }

                // 再创建一个线程，线程过程函数就是FreeLibrary，释放那个dll
                // me32.hModule是模块句柄
                CreateRemoteThread(hProecss, NULL, 0,
                    (LPTHREAD_START_ROUTINE)dwFunAddr, me32.hModule, 0, 0);
            }
        } while (Module32Next(hSnap, &me32));

        return TRUE;
    }
}

int main()
{
    DWORD dwPid = GetProcessIdByName((PWCHAR)TEXT("PETool 1.0.0.5.exe"));
    // printf("%d\r\n", dwPid);

    RemoteThreadInject(dwPid, szBuffer);

    FreeInjectDll(dwPid, (PWCHAR)TEXT("Inject.dll"));
}
```

# 五 第二种远程卸载注入过的dll

![7](./../../操作/9Inject/7.jpg)

当CreateRemoteThread这个API创建的线程执行完之后，默认返回线程过程函数的返回值

这里获取到远程线程执行的LoadLibrary的返回值

这个值就是我们注入的线程的ImageBase，就是注入的dll的模块句柄

```cpp
void RemoteThreadInject(DWORD dwPid, PCHAR szDllPath)
{
    HANDLE hProcess = 0;
    LPVOID pDllPath = 0;
    DWORD dwDllPathSize = 0;
    BOOL bRet = 0;

    HMODULE hModuleKernel32 = 0;
    DWORD dwFunAddr = 0;

    HANDLE hThread;

    // 打开进程，得到指定注入进程句柄
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);
    if (hProcess == NULL)
    {
        printf("OpenProcess Error -> [%x] \r\n", GetLastError());
        return;
    }

    dwDllPathSize = strlen(szDllPath) + 1;
    // 在指定进程中申请内存，存储LoadLibrary的参数(dll的路径)
    pDllPath = VirtualAllocEx(hProcess, NULL, dwDllPathSize, MEM_COMMIT, PAGE_READWRITE);
    if (!pDllPath)
    {
        printf("VirtualAllocEx Error -> [%x]\r\n", GetLastError());
        return;
    }

    // 目标进程中，将Dll路径写入到分配的内存当中
    bRet = WriteProcessMemory(hProcess, pDllPath, szDllPath, dwDllPathSize, NULL);
    if (!bRet)
    {
        printf("WriteProcessMemory Error -> [%x]\r\n", GetLastError());
        return;
    }

    // CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA, pDllPath, 0, NULL);

    // 获取LoadLibraryA
    hModuleKernel32 = LoadLibraryA("Kernel32.dll");
    if (!hModuleKernel32)
    {
        printf("LoadLibraryA Error -> [%x]\r\n", GetLastError());
        return;
    }
    dwFunAddr = (DWORD)GetProcAddress(hModuleKernel32, "LoadLibraryA");

    // 创建远程线程。线程过程函数是LoadLibrary加载我们的dll
    hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)dwFunAddr, pDllPath, 0, NULL);
    if (!hThread)
    {
        printf("CreateRemoteThread Error -> [%x]\r\n", GetLastError());
        return;
    }

    // 等待远程线程结束
    // 因为hThread是一个内核对象，所以可以等待
    WaitForSingleObject(hThread, INFINITE);

    // 线程过程函数的返回值，自动变成线程的退出码
    DWORD dwExitCode = 0;
    GetExitCodeThread(hThread, &dwExitCode);

    // 再来一个远程线程，FreeLibrary，dwExitCode
}
```

# 六 劫持进程注入介绍

劫持进程注入

CreateProcess的时候，将创建进程的方式改成以挂起的方式是创建

进程创建成功，PE文件拉伸到内存，起了一条线程之后，就被挂起了。

此时检测注入的线程代码什么的都还没执行，这时候再远程线程注入

# 七 劫持进程注入代码

```cpp
VOID HijackProcessInject(PCHAR ProcessPath, PCHAR DllPath)
{
    STARTUPINFOA si = { 0 };
    si.cb = sizeof(si);

    PROCESS_INFORMATION pi = { 0 };

    BOOL bRet = FALSE;
    HANDLE hProcess = 0;
    DWORD dwPathSize = 0;

    // 挂起方式创建进程
    bRet = CreateProcessA(
        ProcessPath,
        NULL,
        NULL,
        NULL,
        NULL,
        CREATE_SUSPENDED,   // 以挂起的方式创建进程
        NULL,
        NULL,
        &si,
        &pi
    );
    if (!bRet)
    {
        return;
    }

    hProcess = pi.hProcess;
    dwPathSize = strlen(DllPath) + 1;

    // 跨进程申请内存，存DllPath
    LPVOID lpDll = VirtualAllocEx(hProcess, NULL, dwPathSize, MEM_COMMIT, PAGE_READWRITE);
    if (!lpDll)
    {
        return;
    }

    // DllPath写进目标进程
    WriteProcessMemory(hProcess, lpDll, DllPath, dwPathSize, NULL);

    // 获取自身LoadLibrary地址
    HMODULE hModuleKernel32 = LoadLibraryA("kernel32.dll");
    if (!hModuleKernel32)
    {
        return;
    }
    DWORD dwFunAddr = (DWORD)GetProcAddress(hModuleKernel32, "LoadLibraryA");
    if (!dwFunAddr)
    {
        return;
    }

    // 创建远程线程.线程过程函数就是加载我们要注入的dll
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, 
        (LPTHREAD_START_ROUTINE)dwFunAddr, lpDll, 0, 0);
    if (!hThread)
    {
        return;
    }

    // 等待远程线程执行完。因为hThread是一个句柄(内核对象)
    WaitForSingleObject(hThread, INFINITE);

    // 获取注入DLL的IMAGE_BASE
    DWORD dwExitCode = 0;
    GetExitCodeThread(hThread, &dwExitCode);

    // 远程释放我们分配的内存。写入dll路径的那块内存
    VirtualFreeEx(hProcess, lpDll, dwPathSize, MEM_DECOMMIT);

    // 主线程从挂起恢复
    ResumeThread(pi.hThread);

    // 关闭句柄
    CloseHandle(hThread);
}
```

# 八 消息钩子注入介绍

消息钩子注入

1.拿目标进程id

2.要注入的dll写个导出函数，用来做SetWindowsHookEx的回调函数

3.我们自己进程加载一下要注入的dll，拿到dll的模块基址，再拿这个要注入的dll的某个导出函数的地址

4.遍历所有线程，找到一个目标进程id的线程

5.SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC)dwFunAddr, hModuleInjectDll, te32.th32ThreadID);

// 这个API会在目标线程中，执行dwFunAddr，如果hModuleInjectDll模块没加载，会帮忙加载

# 九 消息钩子注入代码

```cpp
VOID MessageHookInject(DWORD dwPid, PCHAR DllPath)
{
    HHOOK hook = 0;

    // 加载要注入的dll到自身进程
    HMODULE hModuleInjectDll = LoadLibraryA(DllPath);
    if (!hModuleInjectDll)
    {
        return;
    }

    // 获取注入dll中的导出函数地址(随便一个导出函数)。自身进程下的
    DWORD dwFunAddr = (DWORD)GetProcAddress(hModuleInjectDll, "MessageHook");
    if (!dwFunAddr)
    {
        return;
    }

    // 遍历线程
    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (hSnap == INVALID_HANDLE_VALUE)
    {
        return;
    }

    // 初始化线程结构体
    THREADENTRY32 te32 = { 0 };
    te32.dwSize = sizeof(te32);

    // 遍历线程
    if (Thread32First(hSnap, &te32))
    {
        do
        {
            // 找一个线程，属于目标进程
            if (te32.th32OwnerProcessID == dwPid) 
            {
                // 这个API会在目标线程中，执行dwFunAddr，如果hModuleInjectDll模块没加载，会帮忙加载
                // 系统会记录DLL路径和回调函数名。目标进程自动加载dll，自动查找回调函数
                hook = SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC)dwFunAddr, hModuleInjectDll, te32.th32ThreadID);
                break;
            }
        } while (Thread32Next(hSnap, &te32));
    }

    // 卸载hook。也会卸载注入的dll
    UnhookWindowsHookEx(hook);

    // 释放句柄
    CloseHandle(hSnap);
}
```

# 十 APC注入介绍

APC注入

线程中有个Asynchronous Procedure Call，APC调用



TerminateProcess，就是向目标进程的APC成员发消息，关闭所有线程，进程就自动结束了

# 十一 APC注入代码

还是对目标进程中的其中一个线程发消息，执行LoadLibrary

```cpp
VOID UserApcInject(DWORD dwPid, PCHAR DllPath)
{
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);
    if (!hProcess)
    {
        return;
    }

    DWORD dwDllPathSize = strlen(DllPath) + 1;
    LPVOID lpDllPath = VirtualAllocEx(hProcess, NULL, dwDllPathSize, MEM_COMMIT, PAGE_READWRITE);
    if (!lpDllPath)
    {
        return;
    }

    WriteProcessMemory(hProcess, lpDllPath, DllPath, dwDllPathSize, NULL);

    HMODULE hModuleKernel32 = LoadLibraryA("Kernel32.dll");
    if (!hModuleKernel32)
    {
        return;
    }
    DWORD dwFunAddr = (DWORD)GetProcAddress(hModuleKernel32, "LoadLibraryA");

    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (hSnap == INVALID_HANDLE_VALUE)
    {
        return;
    }

    THREADENTRY32 te32 = { 0 };
    te32.dwSize = sizeof(te32);
    if (Thread32First(hSnap, &te32))
    {
        do 
        {
            // 遍历到一个目标进程中的线程
            if (te32.th32OwnerProcessID == dwPid)
            {
                HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID);
                if (!hThread)
                {
                    return;
                }

                // 插入一个APC。且hThread线程必须要有警惕性，不然注入不进去
                QueueUserAPC((PAPCFUNC)dwFunAddr, hThread, (ULONG_PTR)lpDllPath);
                CloseHandle(hThread);

                break;
            }
        } while (Thread32Next(hSnap, &te32));
    }

    CloseHandle(hProcess);
    CloseHandle(hSnap);
}
```

# 十二 注入的dll可以被系统API遍历到

![8](./../../操作/9Inject/8.jpg)

```cpp
#include <iostream>
#include <windows.h>
#include <TlHelp32.h>

// C:\\Users\\Administrator\\Documents\\BaiduSyncdisk\\1Learning\\Reverse\\FerryCofc\\1Game\\Code\\9Inject\\HideModule\\Debug\\TestDll.dll

DWORD WINAPI TravelModule(LPVOID lp)
{
    while (1)
    {
        system("cls");
        HANDLE hSnap = 0;
        MODULEENTRY32 me32 = { 0 };
        me32.dwSize = sizeof(me32);

        // 遍历当前线程所属进程的所有模块
        hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetCurrentProcessId());
        if (hSnap == INVALID_HANDLE_VALUE)
        {
            return 0;
        }

        if (Module32First(hSnap, &me32))
        {
            do
            {
                wprintf(L"%s\r\n", me32.szModule);
            } while (Module32Next(hSnap, &me32));
        }

        CloseHandle(hSnap);

        Sleep(1000);
    }
}

int main()
{
    HANDLE hThread = CreateThread(NULL, 0, TravelModule, NULL, 0, NULL);
    if (hThread == NULL)
    {
        return 0;
    }
    system("pause");

    HMODULE hModule = LoadLibraryA("C:\\Users\\Administrator\\Documents\\BaiduSyncdisk\\1Learning\\Reverse\\FerryCofc\\1Game\\Code\\9Inject\\HideModule\\Debug\\TestDll.dll");
    if (!hModule)
    {
        return 0;
    }
    system("pause");

    CloseHandle(hThread);

    return 0;
}
```

![9](./../../操作/9Inject/9.jpg)

LoadLibrary加载的DLL可以被对方进程遍历到。所以我们要写一个自己的LoadLibrary

# 十三 重写LoadLibrary来隐藏dll-1，PE文件读到内存

```cpp
// 读取模块二进制数据
PCHAR FileToMem(PCHAR szFilePath, LPDWORD lpdwFileSize)
{
    // 打开文件
    FILE* pFile = NULL;
    fopen_s(&pFile, szFilePath, "rb");
    if (pFile == NULL)
    {
        return NULL;
    } 

    DWORD dwFileSize = 0;
    // 获取文件大小
    fseek(pFile, 0, SEEK_END);
    dwFileSize = ftell(pFile);
    fseek(pFile, 0, SEEK_SET);

    // 申请内存
    PCHAR pFileBuffer = (PCHAR)malloc(dwFileSize);
    if (!pFileBuffer)
    {
        fclose(pFile);
        return NULL;
    }
    memset(pFileBuffer, 0, dwFileSize);

    // 读取文件数据
    fread_s(pFileBuffer, dwFileSize, dwFileSize, 1, pFile);

    // 判断是否为PE文件
    if (*(PSHORT)pFileBuffer != IMAGE_DOS_SIGNATURE)
    {
        free(pFileBuffer);
        fclose(pFile);
        return NULL;
    }

    // 判断NT头。pFileBuffer是PCHAR类型的
    if (*(LPDWORD)(*(LPDWORD)(pFileBuffer + 0x3c) + pFileBuffer) != IMAGE_NT_SIGNATURE)
    {
        free(pFileBuffer);
        fclose(pFile);
        return NULL;
    }

    if (lpdwFileSize != NULL)
    {
        *lpdwFileSize = dwFileSize;
    }

    // 关闭文件
    fclose(pFile);

    return pFileBuffer;
}

// 通过自己的LoadLibrary来隐藏模块
VOID HideModuleByLoad(PCHAR szFilePath)
{
    // 1.读取模块二进制数据
    PCHAR pFileBuffer = FileToMem(szFilePath, NULL);
    if (!pFileBuffer)
    {
        return;
    }

    // 2.安装PE文件格式拉伸到内存

    // 3.修复重定位数据

    // 4.修复导入地址表

    // 5.构建GetProcAddress

    // 6.抹除PE指纹

}
```

# 十四 重写LoadLibrary来隐藏dll-2，PE头和节表拉伸到内存

```cpp
// 文件缓存转内存缓存
PCHAR FileBufferToImageBuffer(PCHAR pFileBuff)
{
    PCHAR pImageBuffer = NULL;

    // 定位PE结构
    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pFileBuff;
    PIMAGE_NT_HEADERS pNth = (PIMAGE_NT_HEADERS)(pFileBuff + pDos->e_lfanew);
    PIMAGE_FILE_HEADER pFil = (PIMAGE_FILE_HEADER)((PCHAR)pNth + 4);
    PIMAGE_OPTIONAL_HEADER pOpo = (PIMAGE_OPTIONAL_HEADER)((PCHAR)pFil + IMAGE_SIZEOF_FILE_HEADER);
    PIMAGE_SECTION_HEADER pSec = (PIMAGE_SECTION_HEADER)((PCHAR)pOpo + pFil->SizeOfOptionalHeader);

    // 分配缓冲区
    pImageBuffer = (PCHAR)VirtualAlloc(NULL, pOpo->SizeOfImage, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (!pImageBuffer)
    {
        return NULL;
    }
    memset(pImageBuffer, 0, pOpo->SizeOfImage);

    // 拷贝头加节表数据
    memcpy(pImageBuffer, pFileBuff, pOpo->SizeOfHeaders);

    // 拷贝节区数据
    for (size_t i = 0; i < pFil->NumberOfSections; i++)
    {
        memcpy(
            pImageBuffer + pSec[i].VirtualAddress,
            pFileBuff + pSec[i].PointerToRawData,
            pSec[i].SizeOfRawData
        );
    }

    // 释放文件缓存
    free(pFileBuff);

    return pImageBuffer;
}

// 通过自己的LoadLibrary来隐藏模块
VOID HideModuleByLoad(PCHAR szFilePath)
{
    // 1.读取模块二进制数据
    PCHAR pFileBuffer = FileToMem(szFilePath, NULL);
    if (!pFileBuffer)
    {
        return;
    }

    // 2.安装PE文件格式拉伸到内存
    PCHAR pImageBuffer = FileBufferToImageBuffer(pFileBuffer);
    if (!pImageBuffer)
    {
        return;
    }

    // 3.修复重定位数据

    // 4.修复导入地址表

    // 5.构建GetProcAddress

    // 6.抹除PE指纹

}
```

# 十五 重写LoadLibrary来隐藏dll-3，修复重定位数据

要修复的数据本身就是一个全局变量地址。默认是RVA+IMAGEBASE现在IMAGEBASE改变了而已

![10](./../../操作/9Inject/10.jpg)

```cpp
// 修复重定位数据
VOID RepairRelocationEntry(PCHAR pImageBuffer)
{
    // 定位结构
    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pImageBuffer;
    PIMAGE_NT_HEADERS pNth = (PIMAGE_NT_HEADERS)(pImageBuffer + pDos->e_lfanew);

    // 默认IMAGE_BASE
    DWORD dwOldImageBase = pNth->OptionalHeader.ImageBase;

    // 判断是否有重定位表
    if (pNth->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress == NULL)
    {
        return;
    }

    // 定位第一个重定位结构
    PIMAGE_BASE_RELOCATION pRel = (PIMAGE_BASE_RELOCATION)(pImageBuffer + 
        pNth->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
    
    // 遍历重定位项并修复
    while (pRel->VirtualAddress && pRel->SizeOfBlock)
    {
        // 重定位项基址
        DWORD dwBaseRva = pRel->VirtualAddress;

        // 重定位项的数量
        DWORD dwNumberOfRelEntry = (pRel->SizeOfBlock - 8) / 2;

        // 定位第一个重定位项
        PWORD pRelEntry = (PWORD)((PCHAR)pRel + 8);

        for (size_t i = 0; i < dwNumberOfRelEntry; i++)
        {
            // x86下高4位为0011.x64下是1010.才是一个需要重定位的项
            if ((pRelEntry[i] & 0x3000) == 0x3000)
            {
                // x86下低4位+重定位项基址就是需要修复的数据的RVA
                DWORD dwRva = (pRelEntry[i] & 0x0FFF) + dwBaseRva;

                // 找到要修复的数据的内存地址
                PDWORD pData = (PDWORD)(pImageBuffer + dwRva);

                // 修复数据。初始数据-老的IMAGEBASE+新的IMAGEBASE
                DWORD dwRepair = (DWORD)(*pData - dwOldImageBase + pImageBuffer);

                // 要修复的数据的现在的内存地址写入内容
                *pData = dwRepair;
            }
        }
        
		// 下一个重定位表
        pRel = (PIMAGE_BASE_RELOCATION)((PCHAR)pRel + pRel->SizeOfBlock);
    }
}

// 通过自己的LoadLibrary来隐藏模块
VOID HideModuleByLoad(PCHAR szFilePath)
{
    // 1.读取模块二进制数据
    PCHAR pFileBuffer = FileToMem(szFilePath, NULL);
    if (!pFileBuffer)
    {
        return;
    }

    // 2.安装PE文件格式拉伸到内存
    PCHAR pImageBuffer = FileBufferToImageBuffer(pFileBuffer);
    if (!pImageBuffer)
    {
        return;
    }

    // 3.修复重定位数据
    RepairRelocationEntry(pImageBuffer);

    // 4.修复导入地址表

    // 5.构建GetProcAddress

    // 6.抹除PE指纹

}
```

# 十六 重写LoadLibrary来隐藏dll-4，修复导入地址表

```cpp
// 修复导入表,IAT表
BOOL RepairImportAddressTable(PCHAR pImageBuffer)
{
    // 定位结构
    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pImageBuffer;
    PIMAGE_NT_HEADERS pNth = (PIMAGE_NT_HEADERS)(pImageBuffer + pDos->e_lfanew);

    // 判断是否有导入表
    if (pNth->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress == NULL)
    {
        return FALSE;
    }

    // 定位第一个导入表结构
    PIMAGE_IMPORT_DESCRIPTOR pImp = (PIMAGE_IMPORT_DESCRIPTOR)(pImageBuffer + 
        pNth->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

    // 遍历导入表数据
    while (pImp->OriginalFirstThunk && pImp->FirstThunk)
    {
        // 获取导入模块
        PCHAR pDllName = (PCHAR)(pImageBuffer + pImp->Name);

        // 加载导入模块。得到模块句柄，就是IMAGE_BASE
        HMODULE hModule = LoadLibraryA(pDllName);
        if (!hModule)
        {
            return FALSE;
        }

        // INT IAT
        PDWORD pInt = (PDWORD)(pImageBuffer + pImp->OriginalFirstThunk);
        PDWORD pIat = (PDWORD)(pImageBuffer + pImp->FirstThunk);

        do
        {
            // 修复函数地址
            DWORD dwFunAddr = 0;

            // 判断导入方式
            // 最高位为1，低31位就是导出序号。否则指向PIMAGE_IMPORT_BY_NAME
            if ((*pInt & 0x8000) == 0x80000000)
            {
                // GetProcAddress的第二个参数支持hModule的导出函数的序号
                dwFunAddr == (DWORD)GetProcAddress(hModule, (LPCSTR)(*pInt & 0x7FFFFFFF));
            }
            else if ((*pInt & 0x0) == 0)
            {
                // 序号，函数名。的结构体
                PIMAGE_IMPORT_BY_NAME pName = (PIMAGE_IMPORT_BY_NAME)(pImageBuffer + *pInt);
                dwFunAddr = (DWORD)GetProcAddress(hModule, pName->Name);
            }

            if (!dwFunAddr)
            {
                return FALSE;
            }

            *pIat = dwFunAddr;

            pInt++;
            pIat++;
        } while (*pInt);

        pImp++;// 每个导入表在内存中的大小是固定的
    }

    return TRUE;
}

// 通过自己的LoadLibrary来隐藏模块
VOID HideModuleByLoad(PCHAR szFilePath)
{
    // 1.读取模块二进制数据
    PCHAR pFileBuffer = FileToMem(szFilePath, NULL);
    if (!pFileBuffer)
    {
        return;
    }

    // 2.安装PE文件格式拉伸到内存
    PCHAR pImageBuffer = FileBufferToImageBuffer(pFileBuffer);
    if (!pImageBuffer)
    {
        return;
    }

    // 3.修复重定位数据
    RepairRelocationEntry(pImageBuffer);

    // 4.修复导入地址表
    BOOL bRet = RepairImportAddressTable(pImageBuffer);
    if (!bRet)
    {
        return;
    }
    
    // 5.构建GetProcAddress

    // 6.抹除PE指纹
    
}
```

# 十七 重写LoadLibrary来隐藏dll-5，从导出地址表获取函数地址

```cpp
// 通过函数导出名，定位函数地址
DWORD GetExportFunAddrByName(PCHAR pImageBuffer, PCHAR szFunName)
{
    // 定位结构
    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pImageBuffer;
    PIMAGE_NT_HEADERS pNth = (PIMAGE_NT_HEADERS)(pImageBuffer + pDos->e_lfanew);

    // 判断导出表结构
    if (pNth->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress == NULL)
    {
        return 0;
    }

    // 定位导出表结构
    PIMAGE_EXPORT_DIRECTORY pExp = (PIMAGE_EXPORT_DIRECTORY)(pImageBuffer + 
        pNth->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    // 定位三张表。地址表，名称表，序号表
    LPDWORD lpFunAddr = (LPDWORD)(pImageBuffer + pExp->AddressOfFunctions);
    LPDWORD lpFunName = (LPDWORD)(pImageBuffer + pExp->AddressOfNames);
    LPWORD lpFunOrdi = (LPWORD)(pImageBuffer + pExp->AddressOfNameOrdinals);

    for (size_t i = 0; i < pExp->NumberOfNames; i++)
    {
        if (strcmp(szFunName, (PCHAR)pImageBuffer + lpFunName[i]) == 0)
        {
            return (DWORD)((PCHAR)pImageBuffer + lpFunAddr[lpFunOrdi[i]]);
        }
    }
}

// 通过函数导出序号，定位函数地址
DWORD GetExportFunAddrByOrdinal(PCHAR pImageBuffer, DWORD dwOrdinal)
{
    // 定位结构
    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pImageBuffer;
    PIMAGE_NT_HEADERS pNth = (PIMAGE_NT_HEADERS)(pImageBuffer + pDos->e_lfanew);

    // 判断导出表结构
    if (pNth->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress == NULL)
    {
        return 0;
    }

    // 定位导出表结构
    PIMAGE_EXPORT_DIRECTORY pExp = (PIMAGE_EXPORT_DIRECTORY)(pImageBuffer +
        pNth->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    // 定位三张表。地址表，名称表，序号表
    LPDWORD lpFunAddr = (LPDWORD)(pImageBuffer + pExp->AddressOfFunctions);
    LPDWORD lpFunName = (LPDWORD)(pImageBuffer + pExp->AddressOfNames);
    LPWORD lpFunOrdi = (LPWORD)(pImageBuffer + pExp->AddressOfNameOrdinals);

    return (DWORD)((PCHAR)pImageBuffer + lpFunAddr[dwOrdinal - pExp->Base]);
}

// 通过自己的LoadLibrary来隐藏模块
VOID HideModuleByLoad(PCHAR szFilePath)
{
    // 1.读取模块二进制数据
    PCHAR pFileBuffer = FileToMem(szFilePath, NULL);
    if (!pFileBuffer)
    {
        return;
    }

    // 2.安装PE文件格式拉伸到内存
    PCHAR pImageBuffer = FileBufferToImageBuffer(pFileBuffer);
    if (!pImageBuffer)
    {
        return;
    }

    // 3.修复重定位数据
    RepairRelocationEntry(pImageBuffer);

    // 4.修复导入地址表
    BOOL bRet = RepairImportAddressTable(pImageBuffer);
    if (!bRet)
    {
        return;
    }

    // 5.构建GetProcAddress
    typedef int(_cdecl* Add_Fun)(int, int);

    Add_Fun dwFunAddr1 = (Add_Fun)GetExportFunAddrByName(pImageBuffer, (PCHAR)"Add");

    printf("%d\r\n", dwFunAddr1(1, 2));
    DWORD dwFunAddr2 = GetExportFunAddrByOrdinal(pImageBuffer, 2);

    // 6.抹除PE指纹

}
```

![11](./../../操作/9Inject/11.jpg)

默认的API遍历不到我们加载的dll

# 十八 重写LoadLibrary来隐藏dll-6，抹除PE指纹(PE头清空)

```cpp
#include <iostream>
#include <windows.h>
#include <TlHelp32.h>

// C:\\Users\\Administrator\\Documents\\BaiduSyncdisk\\1Learning\\Reverse\\FerryCofc\\1Game\\Code\\9Inject\\HideModule\\Debug\\TestDll.dll

#define MODULE_PATH "C:\\Users\\Administrator\\Documents\\BaiduSyncdisk\\1Learning\\Reverse\\FerryCofc\\1Game\\Code\\9Inject\\HideModule\\Debug\\TestDll.dll"

PIMAGE_EXPORT_DIRECTORY pExp = 0;

// 遍历模块
DWORD WINAPI TravelModule(LPVOID lp)
{
    while (1)
    {
        system("cls");
        HANDLE hSnap = 0;
        MODULEENTRY32 me32 = { 0 };
        me32.dwSize = sizeof(me32);

        hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetCurrentProcessId());
        if (hSnap == INVALID_HANDLE_VALUE)
        {
            return 0;
        }

        if (Module32First(hSnap, &me32))
        {
            do
            {
                wprintf(L"%s\r\n", me32.szModule);
            } while (Module32Next(hSnap, &me32));
        }

        CloseHandle(hSnap);

        Sleep(1000);
    }
}

// 读取模块二进制数据
PCHAR FileToMem(PCHAR szFilePath, LPDWORD lpdwFileSize)
{
    // 打开文件
    FILE* pFile = NULL;
    fopen_s(&pFile, szFilePath, "rb");
    if (pFile == NULL)
    {
        return NULL;
    } 

    DWORD dwFileSize = 0;
    // 获取文件大小
    fseek(pFile, 0, SEEK_END);
    dwFileSize = ftell(pFile);
    fseek(pFile, 0, SEEK_SET);

    // 申请内存
    PCHAR pFileBuffer = (PCHAR)malloc(dwFileSize);
    if (!pFileBuffer)
    {
        fclose(pFile);
        return NULL;
    }
    memset(pFileBuffer, 0, dwFileSize);

    // 读取文件数据
    fread_s(pFileBuffer, dwFileSize, dwFileSize, 1, pFile);

    // 判断是否为PE文件
    if (*(PSHORT)pFileBuffer != IMAGE_DOS_SIGNATURE)
    {
        free(pFileBuffer);
        fclose(pFile);
        return NULL;
    }

    // 判断NT头。pFileBuffer是PCHAR类型的
    if (*(LPDWORD)(*(LPDWORD)(pFileBuffer + 0x3c) + pFileBuffer) != IMAGE_NT_SIGNATURE)
    {
        free(pFileBuffer);
        fclose(pFile);
        return NULL;
    }

    if (lpdwFileSize != NULL)
    {
        *lpdwFileSize = dwFileSize;
    }

    // 关闭文件
    fclose(pFile);

    return pFileBuffer;
}

// 文件缓存转内存缓存
PCHAR FileBufferToImageBuffer(PCHAR pFileBuff)
{
    PCHAR pImageBuffer = NULL;

    // 定位PE结构
    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pFileBuff;
    PIMAGE_NT_HEADERS pNth = (PIMAGE_NT_HEADERS)(pFileBuff + pDos->e_lfanew);
    PIMAGE_FILE_HEADER pFil = (PIMAGE_FILE_HEADER)((PCHAR)pNth + 4);
    PIMAGE_OPTIONAL_HEADER pOpo = (PIMAGE_OPTIONAL_HEADER)((PCHAR)pFil + IMAGE_SIZEOF_FILE_HEADER);
    PIMAGE_SECTION_HEADER pSec = (PIMAGE_SECTION_HEADER)((PCHAR)pOpo + pFil->SizeOfOptionalHeader);

    // 分配缓冲区
    pImageBuffer = (PCHAR)VirtualAlloc(NULL, pOpo->SizeOfImage, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (!pImageBuffer)
    {
        return NULL;
    }
    memset(pImageBuffer, 0, pOpo->SizeOfImage);

    // 拷贝头加节表数据
    memcpy(pImageBuffer, pFileBuff, pOpo->SizeOfHeaders);

    // 拷贝节区数据
    for (size_t i = 0; i < pFil->NumberOfSections; i++)
    {
        memcpy(
            pImageBuffer + pSec[i].VirtualAddress,
            pFileBuff + pSec[i].PointerToRawData,
            pSec[i].SizeOfRawData
        );
    }

    // 释放文件缓存
    free(pFileBuff);

    return pImageBuffer;
}

// 修复重定位数据。全局变量这些都是RVA，加载到进程后，IMAGEBASE变了，所以要重定位
VOID RepairRelocationEntry(PCHAR pImageBuffer)
{
    // 定位结构
    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pImageBuffer;
    PIMAGE_NT_HEADERS pNth = (PIMAGE_NT_HEADERS)(pImageBuffer + pDos->e_lfanew);

    // 默认IMAGE_BASE
    DWORD dwOldImageBase = pNth->OptionalHeader.ImageBase;

    // 判断是否有重定位表
    if (pNth->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress == NULL)
    {
        return;
    }

    // 定位第一个重定位结构
    PIMAGE_BASE_RELOCATION pRel = (PIMAGE_BASE_RELOCATION)(pImageBuffer + 
        pNth->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
    
    // 遍历重定位项并修复
    while (pRel->VirtualAddress && pRel->SizeOfBlock)
    {
        // 重定位项基址
        DWORD dwBaseRva = pRel->VirtualAddress;

        // 重定位项的数量
        DWORD dwNumberOfRelEntry = (pRel->SizeOfBlock - 8) / 2;

        // 定位第一个重定位项
        PWORD pRelEntry = (PWORD)((PCHAR)pRel + 8);

        for (size_t i = 0; i < dwNumberOfRelEntry; i++)
        {
            // x86下高4位为0011.x64下是1010.才是一个需要重定位的项
            if ((pRelEntry[i] & 0x3000) == 0x3000)
            {
                // x86下低4位+重定位项基址就是需要修复的数据的RVA
                DWORD dwRva = (pRelEntry[i] & 0x0FFF) + dwBaseRva;

                // 找到要修复的数据的现在的内存地址
                PDWORD pData = (PDWORD)(pImageBuffer + dwRva);

                // 修复完成的数据
                DWORD dwRepair = (DWORD)(*pData - dwOldImageBase + pImageBuffer);

                // 要修复的数据的现在的内存地址写入内容
                *pData = dwRepair;
            }
        }
        
        pRel = (PIMAGE_BASE_RELOCATION)((PCHAR)pRel + pRel->SizeOfBlock);
    }
}

// 修复导入表,IAT表。
BOOL RepairImportAddressTable(PCHAR pImageBuffer)
{
    // 定位结构
    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pImageBuffer;
    PIMAGE_NT_HEADERS pNth = (PIMAGE_NT_HEADERS)(pImageBuffer + pDos->e_lfanew);

    // 判断是否有导入表
    if (pNth->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress == NULL)
    {
        return FALSE;
    }

    // 定位第一个导入表结构
    PIMAGE_IMPORT_DESCRIPTOR pImp = (PIMAGE_IMPORT_DESCRIPTOR)(pImageBuffer + 
        pNth->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

    // 遍历导入表数据
    while (pImp->OriginalFirstThunk && pImp->FirstThunk)
    {
        // 获取导入模块
        PCHAR pDllName = (PCHAR)(pImageBuffer + pImp->Name);

        // 加载导入模块
        HMODULE hModule = LoadLibraryA(pDllName);
        if (!hModule)
        {
            return FALSE;
        }

        // INT IAT
        PDWORD pInt = (PDWORD)(pImageBuffer + pImp->OriginalFirstThunk);
        PDWORD pIat = (PDWORD)(pImageBuffer + pImp->FirstThunk);

        do
        {
            // 修复函数地址
            DWORD dwFunAddr = 0;

            // 判断导入方式
            // 最高位为1，低31位就是导出序号。否则指向PIMAGE_IMPORT_BY_NAME
            if ((*pInt & 0x8000) == 0x80000000)
            {
                // GetProcAddress的第二个参数支持hModule的导出函数的序号
                dwFunAddr == (DWORD)GetProcAddress(hModule, (LPCSTR)(*pInt & 0x7FFFFFFF));

            }
            else if ((*pInt & 0x0) == 0)
            {
                // 序号，函数名。的结构体
                PIMAGE_IMPORT_BY_NAME pName = (PIMAGE_IMPORT_BY_NAME)(pImageBuffer + *pInt);
                dwFunAddr = (DWORD)GetProcAddress(hModule, pName->Name);
            }

            if (!dwFunAddr)
            {
                return FALSE;
            }

            *pIat = dwFunAddr;

            pInt++;
            pIat++;
        } while (*pInt);

        pImp++;// 每个导入表在内存中的大小是固定的
    }

    return TRUE;
}

// 通过函数导出名，定位函数地址
DWORD GetExportFunAddrByName(PCHAR pImageBuffer, PCHAR szFunName)
{
    //// 定位结构
    //PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pImageBuffer;
    //PIMAGE_NT_HEADERS pNth = (PIMAGE_NT_HEADERS)(pImageBuffer + pDos->e_lfanew);

    //// 判断导出表结构
    //if (pNth->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress == NULL)
    //{
    //    return 0;
    //}

    //// 定位导出表结构
    //PIMAGE_EXPORT_DIRECTORY pExp = (PIMAGE_EXPORT_DIRECTORY)(pImageBuffer + 
    //    pNth->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    // 定位三张表。地址表，名称表，序号表
    LPDWORD lpFunAddr = (LPDWORD)(pImageBuffer + pExp->AddressOfFunctions);
    LPDWORD lpFunName = (LPDWORD)(pImageBuffer + pExp->AddressOfNames);
    LPWORD lpFunOrdi = (LPWORD)(pImageBuffer + pExp->AddressOfNameOrdinals);

    for (size_t i = 0; i < pExp->NumberOfNames; i++)
    {
        if (strcmp(szFunName, (PCHAR)pImageBuffer + lpFunName[i]) == 0)
        {
            return (DWORD)((PCHAR)pImageBuffer + lpFunAddr[lpFunOrdi[i]]);
        }
    }
}

// 通过函数导出序号，定位函数地址
DWORD GetExportFunAddrByOrdinal(PCHAR pImageBuffer, DWORD dwOrdinal)
{
    //// 定位结构
    //PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pImageBuffer;
    //PIMAGE_NT_HEADERS pNth = (PIMAGE_NT_HEADERS)(pImageBuffer + pDos->e_lfanew);

    //// 判断导出表结构
    //if (pNth->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress == NULL)
    //{
    //    return 0;
    //}

    //// 定位导出表结构
    //PIMAGE_EXPORT_DIRECTORY pExp = (PIMAGE_EXPORT_DIRECTORY)(pImageBuffer +
    //    pNth->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    // 定位三张表。地址表，名称表，序号表
    LPDWORD lpFunAddr = (LPDWORD)(pImageBuffer + pExp->AddressOfFunctions);
    LPDWORD lpFunName = (LPDWORD)(pImageBuffer + pExp->AddressOfNames);
    LPWORD lpFunOrdi = (LPWORD)(pImageBuffer + pExp->AddressOfNameOrdinals);

    return (DWORD)((PCHAR)pImageBuffer + lpFunAddr[dwOrdinal - pExp->Base]);
}

// 抹除PE指纹
VOID RemovePEInfo(PCHAR pImageBuffer)
{
    // 定位结构
    PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pImageBuffer;
    PIMAGE_NT_HEADERS pNth = (PIMAGE_NT_HEADERS)(pImageBuffer + pDos->e_lfanew);

    // 备份导出表地址
    pExp = (PIMAGE_EXPORT_DIRECTORY)(pImageBuffer +
        pNth->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    // 抹除PE指纹
    memset(pImageBuffer, 0, pNth->OptionalHeader.SizeOfHeaders);
}

// 通过自己的LoadLibrary来隐藏模块
VOID HideModuleByLoad(PCHAR szFilePath)
{
    // 1.读取模块二进制数据
    PCHAR pFileBuffer = FileToMem(szFilePath, NULL);
    if (!pFileBuffer)
    {
        return;
    }

    // 2.安装PE文件格式拉伸到内存
    PCHAR pImageBuffer = FileBufferToImageBuffer(pFileBuffer);
    if (!pImageBuffer)
    {
        return;
    }

    // 3.修复重定位数据
    RepairRelocationEntry(pImageBuffer);

    // 4.修复导入地址表
    BOOL bRet = RepairImportAddressTable(pImageBuffer);
    if (!bRet)
    {
        return;
    }

    // 5.抹除PE指纹
    RemovePEInfo(pImageBuffer);

    // 6.构建GetProcAddress
    typedef int(_cdecl* Add_Fun)(int, int);

    Add_Fun dwFunAddr1 = (Add_Fun)GetExportFunAddrByName(pImageBuffer, (PCHAR)"Add");

    printf("%d\r\n", dwFunAddr1(1, 2));
    DWORD dwFunAddr2 = GetExportFunAddrByOrdinal(pImageBuffer, 2);
}

int main()
{
    //HANDLE hThread = CreateThread(NULL, 0, TravelModule, NULL, 0, NULL);
    //if (hThread == NULL)
    //{
    //    return 0;
    //}
    //system("pause");
    
    HideModuleByLoad((PCHAR)MODULE_PATH);

    return 0;
}
```

## **LoadLibrary和GetProcAddress底层做的事情跟这里是一样的，只不过LoadLibrary会向系统PEB登记**，而我们自己实现一遍LoadLibrary没有在PEB登记

# 十九 段寄存器介绍

![12](./../../操作/9Inject/12.jpg)

CS,DS这些展示出来的只是段选择子，2字节

每执行一行代码，都触发了一次CS

# 二十 TEB,PEB结构体介绍

```url
https://ntdiff.github.io/
```

![13](./../../操作/9Inject/13.jpg)

![14](./../../操作/9Inject/14.jpg)

# 二十一 TEB隐藏dll代码

TEB隐藏dll。把这个dll的LDR从双向链表里删除

```cpp
#pragma once
#include <iostream>
#include <windows.h>
#include <TlHelp32.h>


#define MODULE_PATH "C:\\Users\\Administrator\\Documents\\BaiduSyncdisk\\1Learning\\Reverse\\FerryCofc\\1Game\\Code\\9Inject\\HideModule\\Debug\\TestDll.dll"

PIMAGE_EXPORT_DIRECTORY pExp = 0;

typedef struct _PEB_LDR_DATA
{
    /* 0x0000 */ unsigned long Length;
    /* 0x0004 */ unsigned char Initialized;
    /* 0x0008 */ void* SsHandle;
    /* 0x0010 */ struct _LIST_ENTRY InLoadOrderModuleList;
    /* 0x0020 */ struct _LIST_ENTRY InMemoryOrderModuleList;
    /* 0x0030 */ struct _LIST_ENTRY InInitializationOrderModuleList;
    /* 0x0040 */ void* EntryInProgress;
    /* 0x0048 */ unsigned char ShutdownInProgress;
    /* 0x0050 */ void* ShutdownThreadId;
} PEB_LDR_DATA, * PPEB_LDR_DATA; /* size: 0x0058 */

typedef struct _UNICODE_STRING
{
    /* 0x0000 */ unsigned short Length;
    /* 0x0002 */ unsigned short MaximumLength;
    /* 0x0008 */ wchar_t* Buffer;
} UNICODE_STRING, * PUNICODE_STRING; /* size: 0x0010 */

typedef struct _LDR_DATA_TABLE_ENTRY
{
    /* 0x0000 */ struct _LIST_ENTRY InLoadOrderLinks;
    /* 0x0010 */ struct _LIST_ENTRY InMemoryOrderLinks;
    /* 0x0020 */ struct _LIST_ENTRY InInitializationOrderLinks;
    /* 0x0030 */ void* DllBase;
    /* 0x0038 */ void* EntryPoint;
    /* 0x0040 */ unsigned long SizeOfImage;
    /* 0x0048 */ struct _UNICODE_STRING FullDllName;
    /* 0x0058 */ struct _UNICODE_STRING BaseDllName;
}LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY; /* size: 0x0138 */

// 隐藏模块
BOOL HideModuleByRemoveList(PWCHAR szModuleName)
{
    PPEB_LDR_DATA pLdr = NULL;

    __asm
    {
        mov eax, fs: [0x30]      // 定位到TEB
        mov eax, [eax + 0xC]    // 定位到PEB

        mov [pLdr], eax         // 定位到PEB_LDR_DATA
    }

    // 定位到LDR_DATA_TABLE_ENTRY
    PLDR_DATA_TABLE_ENTRY pData = (PLDR_DATA_TABLE_ENTRY)pLdr->InLoadOrderModuleList.Flink;

    PLDR_DATA_TABLE_ENTRY pFlag = pData;
    do
    {
        if (pData->BaseDllName.Buffer == NULL)
        {
            return;
        }

        if (wcscmp(pData->BaseDllName.Buffer, szModuleName) == 0)
        {
            // forward，backward
            pData->InLoadOrderLinks.Flink->Blink = pData->InLoadOrderLinks.Blink;
            pData->InLoadOrderLinks.Blink->Flink = pData->InLoadOrderLinks.Flink;

            pData->InMemoryOrderLinks.Flink->Blink = pData->InMemoryOrderLinks.Blink;
            pData->InMemoryOrderLinks.Blink->Flink = pData->InMemoryOrderLinks.Flink;

            pData->InInitializationOrderLinks.Flink->Blink = pData->InInitializationOrderLinks.Blink;
            pData->InInitializationOrderLinks.Blink->Flink = pData->InInitializationOrderLinks.Flink;
        }


        wprintf_s(TEXT("%s\r\n"), pData->BaseDllName.Buffer);

        pData = (PLDR_DATA_TABLE_ENTRY)pData->InLoadOrderLinks.Flink;
    } while (pFlag != pData);
}

// 遍历模块
DWORD WINAPI TravelModule(LPVOID lp)
{
    while (1)
    {
        system("cls");
        HANDLE hSnap = 0;
        MODULEENTRY32 me32 = { 0 };
        me32.dwSize = sizeof(me32);

        hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetCurrentProcessId());
        if (hSnap == INVALID_HANDLE_VALUE)
        {
            return 0;
        }

        if (Module32First(hSnap, &me32))
        {
            do
            {
                wprintf(L"%s\r\n", me32.szModule);
            } while (Module32Next(hSnap, &me32));
        }

        CloseHandle(hSnap);

        Sleep(1000);
    }
}

int main()
{
    HANDLE hThread = CreateThread(NULL, 0, TravelModule, NULL, 0, NULL);
    if (hThread == NULL)
    {
        return 0;
    }
    system("pause");

    // HideModuleByLoad((PCHAR)MODULE_PATH);

    LoadLibraryA(MODULE_PATH);
    system("pause");

    HideModuleByRemoveList((PWCHAR)L"TestDll.dll");
    system("pause");

    return 0;
}
```

# 二十二 劫持线程注入介绍

劫持线程注入

![15](./../../操作/9Inject/15.jpg)

PUSHAD，所有通用寄存器压栈

PUSHFD，所有标志寄存器压栈

# 二十三 劫持线程注入代码

```cpp
// 劫持线程注入
VOID HijackThreadInject(DWORD dwPid, PCHAR DllPath)
{
    HANDLE hThread = 0;
    // 打开进程
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);
    if (!hProcess)
    {
        return;
    }

    // SHELLCODE
    CHAR szCode[] = {
        0x68, 0x00, 0x00, 0x00, 0x00,       // PUSH RETADDR
        0x60,                               // PUSHAD
        0x9C,                               // PUSHFD
        0x68, 0x00, 0x00, 0x00, 0x00,       // PUSH DLLPATH
        0xB8, 0x00, 0x00, 0x00, 0x00,       // MOV EAX, LoadLibraryA
        0xFF, 0xD0,                         // CALL EAX
        0x9D,                               // POPFD
        0x61,                               // POPAD
        0xC3                                // RET
    };

    // 在目标进程申请内存
    PCHAR pData = (PCHAR)VirtualAllocEx(hProcess, NULL, 0x1000, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (!pData)
    {
        return;
    }

    // 写入DLLPATH
    WriteProcessMemory(hProcess, pData + sizeof(szCode), DllPath, strlen(DllPath) + 1, NULL);
    
    THREADENTRY32 te32 = { 0 };
    te32.dwSize = sizeof(te32);
    // 遍历目标进程中的所有线程
    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (hSnap == INVALID_HANDLE_VALUE)
    {
        return;
    }

    if (Thread32First(hSnap, &te32))
    {
        do 
        {
            if (te32.th32OwnerProcessID == dwPid)
            {
                hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID);
                if (hThread)
                {
                    break;
                }
            }
        } while (Thread32Next(hSnap, &te32));
    }

    if (!hThread)
    {
        return;
    }

    // 挂起线程
    SuspendThread(hThread);

    CONTEXT ctx = { 0 };
    ctx.ContextFlags = CONTEXT_ALL;
    // 获取线程上下文
    GetThreadContext(hThread, &ctx);

    // 修正返回地址
    *(LPDWORD)&szCode[1] = ctx.Eip;

    // 修正DLLPATH
    *(LPDWORD)&szCode[8] = (DWORD)(pData + sizeof(szCode));

    // 修正函数地址
    *(LPDWORD)&szCode[13] = (DWORD)LoadLibraryA;

    // 写入构建代码
    WriteProcessMemory(hProcess, pData, szCode, sizeof(szCode), NULL);

    ctx.Eip = (DWORD)pData;
    // 恢复线程上下文
    SetThreadContext(hThread, &ctx);

    // 恢复挂起线程
    ResumeThread(hThread);
}

int main()
{
    // 获取要注入的进程ID
    DWORD dwPid = GetProcessIdByName((PWCHAR)TEXT("PETool 1.0.0.5.exe"));

    HijackThreadInject(dwPid, szBuffer);
}
```

![16](./../../操作/9Inject/16.jpg)

![17](./../../操作/9Inject/17.jpg)
