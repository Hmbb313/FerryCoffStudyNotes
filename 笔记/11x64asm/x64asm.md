# 零 寄存器

新增8个通用寄存器，r8-r15

![1](./../../操作/11x64asm/1.jpg)

rflag是64位，但是只用了32位



内联汇编目前不支持x64

![2](./../../操作/11x64asm/2.jpg)

# 一 内存布局和线性地址

![3](./../../操作/11x64asm/3.jpg)

x86下，地址占64位，8字节，但是前16为是第47位符号位的扩展

0x00000000-00000000	-	0x00007FFF-FFFFFFFF	用户的

0xFFFF8000-00000000	-	0xFFFFFFFF-FFFFFFFF	内核的

# 二 通用寄存器规则

![4](./../../操作/11x64asm/4.jpg)

AH,AL

AX

都只影响对应的位数

EAX

会影响RAX相对于EAX的高位，会被抹掉

如果RAX操作数不足8字节，会自动变成EAX

![5](./../../操作/11x64asm/5.jpg)

R8-R15也可以操作低32位，低16位，低8位

R8D

R8W

R8B

操作R8D的时候跟操作EAX一样，也会将高32位抹掉

# 三 内存寻址

![6](./../../操作/11x64asm/6.jpg)

RAX+0x4,读到的是0x9612CFF91C的数据，也就是0x00007FFD

![7](./../../操作/11x64asm/7.jpg)

![8](./../../操作/11x64asm/8.jpg)

# 四 指针宽度

char* pChar	 影响这个地址的1位

shot* pShort	影响这个地址的2位

int* pInt		影响这个地址的4位



x64下char，short，int的数据宽度还是跟x86下一样

# 五 调用约定

x86下有3个调用约定

![9](./../../操作/11x64asm/9.jpg)

x64下只有fastcall

![10](./../../操作/11x64asm/10.jpg)

# 六 x64堆栈图(fastcall)(4个参数)

![11](./../../操作/11x64asm/11.jpg)

![12](./../../操作/11x64asm/12.jpg)

![13](./../../操作/11x64asm/13.jpg)

# 七 x64堆栈图(大于4个参数)

![15](./../../操作/11x64asm/15.jpg)

只用到4个寄存器来传参，剩下的直接放到rsp+的位置

VS2015

![14](./../../操作/11x64asm/14.jpg)

最后会将RSP降下来，用RSP寻址

# 八 x64写内联汇编

![16](./../../操作/11x64asm/16.jpg)

![17](./../../操作/11x64asm/17.jpg)

![18](./../../操作/11x64asm/18.jpg)

必须是main.cpp，不然编译有问题。





























































