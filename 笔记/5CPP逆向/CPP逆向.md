# 零 类的内存布局

类的内存布局

![1](./../../操作/5CPP逆向/1.jpg)

# 一 结构体/类的内存对齐

结构体/类的内存对齐。默认为8

![2](./../../操作/5CPP逆向/2.jpg)

![3](./../../操作/5CPP逆向/3.jpg)

sizeof的大小又要是成员最大类型大小的整数倍。所以是16

设置结构体对齐为1

![4](./../../操作/5CPP逆向/4.jpg)

# 二 静态变量

静态变量，只会**初始化**一次

![5](./../../操作/5CPP逆向/5.jpg)

类中的静态成员变量，所有的对象共享一份

![6](./../../操作/5CPP逆向/6.jpg)

![7](./../../操作/5CPP逆向/7.jpg)

生命周期是全局。作用域限制在函数中或者类中

# 三 类成员寻址

类成员寻址

![8](./../../操作/5CPP逆向/8.jpg)

计算类成员的偏移

![9](./../../操作/5CPP逆向/9.jpg)

&(((User*)NULL)->a)就是一个地址，只不过NULL是0地址，这个地址跟User类的a成员的偏移相等

# 四 thiscall

thiscall

![10](./../../操作/5CPP逆向/10.jpg)

![11](./../../操作/5CPP逆向/11.jpg)

![12](./../../操作/5CPP逆向/12.jpg)

![13](./../../操作/5CPP逆向/13.jpg)

也是内部平栈

# 五 thiscall反汇编

![14](./../../操作/5CPP逆向/14.jpg)

rep要使用ecx，所以ecx先入栈保存

![15](./../../操作/5CPP逆向/15.jpg)

取出类对象的地址，赋值给this指针(ebp-8)

也可以强行将类成员函数的调用约定改为其他的

![16](./../../操作/5CPP逆向/16.jpg)

只是将类对象首地址当参数push进去

# 六 类作为参数传递

类作为参数传递

![17](./../../操作/5CPP逆向/17.jpg)

![18](./../../操作/5CPP逆向/18.jpg)

类对象的所有成员当成参数入栈

![19](./../../操作/5CPP逆向/19.jpg)

直接将类对象的成员变量完全拷贝过去，作为参数

也可以传指针，直接把对象首地址当参数传递

# 七 类对象做返回值

类对象做返回值

![20](./../../操作/5CPP逆向/20.jpg)

![21](./../../操作/5CPP逆向/21.jpg)

用eax和edx来返回

![22](./../../操作/5CPP逆向/22.jpg)

临时中转了一下



类成员占用大空间的情况

![23](./../../操作/5CPP逆向/23.jpg)

先压入一个地址。这个函数是没有参数的。

![24](./../../操作/5CPP逆向/24.jpg)

![25](./../../操作/5CPP逆向/25.jpg)

main函数中调Fun函数参数传了个地址，将Fun函数内部的类拷贝到传递的那个地址。这是个临时的中转的地址，main函数中

![26](./../../操作/5CPP逆向/26.jpg)

然后将临时中转的，拷贝到main局部变量的位置

# 八 堆对象、局部对象、全局对象

### 堆对象

new的对象

![27](./../../操作/5CPP逆向/27.jpg)

先new一个内存，再将这个内存作为类对象首地址。因为是初始化，所以要thiscall调用构造

### 局部对象

![28](./../../操作/5CPP逆向/28.jpg)

thiscall传首地址，调构造

### 全局对象

![29](./../../操作/5CPP逆向/29.jpg)

![30](./../../操作/5CPP逆向/30.jpg)

全局对象，编译器已经知道了他的地址了，所以不用thiscall传首地址

还没执行到main函数

# 九 局部对象和堆对象的析构

局部对象，析构

![31](./../../操作/5CPP逆向/31.jpg)

![32](./../../操作/5CPP逆向/32.jpg)

堆对象

![33](./../../操作/5CPP逆向/33.jpg)

delete里面判断了地址是否为空

这里编译器优化了，实际上调用了析构的。先析构了，再释放堆空间

# 十 继承中的析构，虚析构

![34](./../../操作/5CPP逆向/34.jpg)

子类的构造里面先调用了父类的构造，再执行子类构造的功能代码，传的是子类的this指针

![35](./../../操作/5CPP逆向/35.jpg)

子类析构的时候，先执行子类析构的功能代码(释放自己新写的成员变量)，再调用父类的析构(释放从父类继承的成员变量)

![36](./../../操作/5CPP逆向/36.jpg)

不管是不是虚析构，都会先析构子类单独的，再析构从父类继承的。

虚函数只会在多肽的时候产生作用。也就是子类给父类的指针和引用赋值的时候。

# 十一 继承的内存布局

内存布局

![37](./../../操作/5CPP逆向/37.jpg)

子类的构造里面先调用了父类的构造，再执行子类构造的功能代码，传的是子类的this指针

所以内存布局先是父类的，再是子类的

# 十二 多层继承

多层继承

![38](./../../操作/5CPP逆向/38.jpg)

获取Son2的首地址，调Son2的构造，Son2的构造中调Son1的构造，Son1的构造里面调Base的构造

# 十三 多重继承

多重继承

![39](./../../操作/5CPP逆向/39.jpg)

![40](./../../操作/5CPP逆向/40.jpg)

先拿this指针，然后按顺序调继承的那两个构造，再执行自身构造的功能代码

虽然这三个构造函数传递的this指针是同一个，但是编译器会自动算偏移😂

# 十四 虚函数地址表

![41](./../../操作/5CPP逆向/41.jpg)

虚函数地址表

![42](./../../操作/5CPP逆向/42.jpg)

# 十五 带虚函数的类对象的构造

带虚函数的类对象的构造

![43](./../../操作/5CPP逆向/43.jpg)

虚表编译完就存在了，所以直接给this指针的内容赋值



直接调成员函数

![44](./../../操作/5CPP逆向/44.jpg)

通过虚表调成员函数

![45](./../../操作/5CPP逆向/45.jpg)

先取出对象首地址，再从对象首地址访问得到虚表，先将对象首地址传入ecx，再调虚表中的函数

# 十六 直接调用和间接调用，call

直接调用和间接调用，call

![46](./../../操作/5CPP逆向/46.jpg)

直接调用，E8开头。E8 call

call的地址(函数要执行的地址) - call指令下一行的地址 == E8后面的地址

![47](./../../操作/5CPP逆向/47.jpg)

# 十七 继承时，构造函数的汇编

继承的时候，先调父类的构造，首地址放父类的虚表。再执行功能代码，重写虚表，指向自己的虚表(编译完就存在了)

![48](./../../操作/5CPP逆向/48.jpg)

![49](./../../操作/5CPP逆向/49.jpg)

# 十八 指针方式访问虚表

![50](./../../操作/5CPP逆向/50.jpg)

![51](./../../操作/5CPP逆向/51.jpg) 

# 十九 虚函数的内存布局

每个类对象首地址四字节都有一个自己的虚表指针，只要有虚函数。不同对象的虚表指针地址是不同的

调用的时候，走自己的虚表调用自己的函数就行了

继承中，子类虚表中首先放父类的虚函数地址，再放自己的虚函数地址。如果重写了父类的虚函数，虚表中会将父类的虚函数地址替换为自己的

# 二十 多重继承、两个虚表

多重继承

![52](./../../操作/5CPP逆向/52.jpg)

两个虚表

![53](./../../操作/5CPP逆向/53.jpg)

![54](./../../操作/5CPP逆向/54.jpg)
