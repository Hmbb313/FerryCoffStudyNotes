# 一 cout

![1](./../../操作/4CPP/1.jpg)

# 二 cout以其他进制输出

![2](./../../操作/4CPP/2.jpg)

showbase，会将进制的前缀补齐

noshowbase，关闭进制前缀显示

![3](./../../操作/4CPP/3.jpg)

# 三 整数类型

整数

![4](./../../操作/4CPP/4.jpg)

# 四 浮点数

浮点数

![5](./../../操作/4CPP/5.jpg)

指定精度输出

科学计数法输出

恢复原始的输出

# 五 using

using

![6](./../../操作/4CPP/6.jpg)

size_t就是unsigned int

# 六 auto

auto，不会影响运行效率，编译期间推导出来的类型。编译之后就是正常的类型了，auto相当于占位符

![7](./../../操作/4CPP/7.jpg)

typeid，推导出变量的类型

# 七 类型转换

类型转换



隐式转换

![8](./../../操作/4CPP/8.jpg)

答案是num2由int转换成了unsigned int，是正确的。发生了隐式转换。num2由负数转换为一个正数，非常大

![9](./../../操作/4CPP/9.jpg)

将结果转换为int类型表示

# 八 wcout

wcout

![10](./../../操作/4CPP/10.jpg)

UNICODE是万国码，要制定地区才能正常输出

![11](./../../操作/4CPP/11.jpg)

# 九 enum class

enum，全局作用域

![12](./../../操作/4CPP/12.jpg)

enum class，有独立的作用域

![13](./../../操作/4CPP/13.jpg)

# 十 namespace

namespace，就是一个作用域，里面可以写变量，函数，结构体，类....所有东西

namespace必须写在全局作用域下面

![14](./../../操作/4CPP/14.jpg)

命名空间可以嵌套定义

![15](./../../操作/4CPP/15.jpg)

# 十一 using std::cout;

using namespace

![16](./../../操作/4CPP/16.jpg)

直接using namespace std;里面的东西太多了，很容易二义性，只用需要的就好了

# 十二 变量作用域

变量作用域

![17](./../../操作/4CPP/17.jpg)

```c
::a		//指定使用全局变量
```

# 十三 string类型

字符串类型

![18](./../../操作/4CPP/18.jpg)

priintf("%s \r\n", &a)，的参数是一个char*指针，这里有隐式转换

# 十四 string和const char*转换

转换

![19](./../../操作/4CPP/19.jpg)

![20](./../../操作/4CPP/20.jpg)

![21](./../../操作/4CPP/21.jpg)

# 十五 string的操作函数

size和len

![22](./../../操作/4CPP/22.jpg)

![23](./../../操作/4CPP/23.jpg)

构造函数，初始化

![24](./../../操作/4CPP/24.jpg)

![132](./../../操作/4CPP/132.jpg)

# 十六 字符串拼接

字符串拼接

![25](./../../操作/4CPP/25.jpg)

string的拼接。字符串转int，int转字符串

![26](./../../操作/4CPP/26.jpg)

# 十七 前++和后++的反汇编

前++和后++

![27](./../../操作/4CPP/27.jpg)

加减乘除

![28](./../../操作/4CPP/28.jpg)

# 十八 比较运算符

比较运算符

![29](./../../操作/4CPP/29.jpg)

# 十九 三目运算符

三目运算符

![30](./../../操作/4CPP/30.jpg)

将三目运算符的结果，赋值为100

# 二十 switch...case...

switch...case...

![31](./../../操作/4CPP/31.jpg)

# 二十一 C++17好用的功能

改为C++17标准

![32](./../../操作/4CPP/32.jpg)

![33](./../../操作/4CPP/33.jpg)

仅在if...else...里使用

![34](./../../操作/4CPP/34.jpg)

仅在switch...case...里使用

# 二十二 for循环

for循环

![35](./../../操作/4CPP/35.jpg)

# 二十三 while

while

![36](./../../操作/4CPP/36.jpg)

# 二十四 遍历数组

遍历数组

![37](./../../操作/4CPP/37.jpg)

# 二十五 array

array

![38](./../../操作/4CPP/38.jpg)

迭代器

![39](./../../操作/4CPP/39.jpg)

设置数组中全部元素的值都为123

![40](./../../操作/4CPP/40.jpg)

at(4)跟[4]是一样的

# 二十六 vector

vector

![41](./../../操作/4CPP/41.jpg)

动态扩容

![42](./../../操作/4CPP/42.jpg)

重新分配

# 二十七 指针

指针

![43](./../../操作/4CPP/43.jpg)

# 二十八 指针=地址+解释方式

指针=地址+解释方式

![44](./../../操作/4CPP/44.jpg)

pi影响4字节，pc影响1个字节

# 二十九 常量指针、指针常量

常量指针，指向常量的指针，不能修改指针指向的那个内存的值

const int * p = &a;// 指向的是const int类型，所以不能修改

![45](./../../操作/4CPP/45.jpg)

指针常量，不能修改指针的指向，因为是个常量

# 三十 引用

引用，跟指针的反汇编一模一样

![46](./../../操作/4CPP/46.jpg)

起别名

![47](./../../操作/4CPP/47.jpg)

# 三十一 malloc

malloc

![48](./../../操作/4CPP/48.jpg)

# 三十二 new

new

![49](./../../操作/4CPP/49.jpg)

# 三十三 野指针、空指针

野指针，free掉没有赋null值

空指针，0地址不能访问

# 三十四 函数

函数

参数？返回值？		有？无？

三种调用约定

# 三十五 宏函数

宏函数

![50](./../../操作/4CPP/50.jpg)

![51](./../../操作/4CPP/51.jpg)

Add函数的汇编有接近30行。宏函数直接替换，效率高很多。

# 三十六 内联函数

内联函数。将函数变成宏函数



宏函数，无脑替换

![52](./../../操作/4CPP/52.jpg)

结果是22。因为只是文本替换((++a) > (b)) ? (++a): (b)

![53](./../../操作/4CPP/53.jpg)

![54](./../../操作/4CPP/54.jpg)

![55](./../../操作/4CPP/55.jpg)

# 三十七 函数指针

函数原型类型，函数指针

是一种新的类型，不是变量。

![56](./../../操作/4CPP/56.jpg)

# 三十八 回调函数

回调函数

![57](./../../操作/4CPP/57.jpg)

函数也有一个类型。函数指针是这个函数的类型的指针

# 三十九 值传递，地址传递

值传递，地址传递

swap(a, b)函数

# 四十 数组和指针，[]操作

数组和指针，[]操作

![58](./../../操作/4CPP/58.jpg)

指针[]，先把指针里的内容拿出来(就是数组首地址)

数组名传参

![59](./../../操作/4CPP/59.jpg)

# 四十一 引用的反汇编

引用的反汇编跟指针一模一样

![60](./../../操作/4CPP/60.jpg)

传参的指针可能在函数内部由于疏忽而被修改

引用就不能修改指向

![61](./../../操作/4CPP/61.jpg)

常量引用

# 四十二 默认参

默认参

![62](./../../操作/4CPP/62.jpg)

# 四十三 main函数的参数

main函数的参数

![63](./../../操作/4CPP/63.jpg)

命令行参数个数。默认为1

![64](./../../操作/4CPP/64.jpg)

# 四十四 不定参

不定参

![65](./../../操作/4CPP/65.jpg)

![66](./../../操作/4CPP/66.jpg)

# 四十五 函数重载

函数重载

![67](./../../操作/4CPP/67.jpg)

1.同一作用域

2.同名

3.参数的类型，个数，顺序不同

# 四十六 template模板

template

![68](./../../操作/4CPP/68.jpg)

# 四十七 函数总结

函数总结

# 四十八 #ifdef，预处理指令

#ifdef，预处理指令

![69](./../../操作/4CPP/69.jpg)

# 四十九 预定义宏

预定义宏

![70](./../../操作/4CPP/70.jpg)

![71](./../../操作/4CPP/71.jpg)

![72](./../../操作/4CPP/72.jpg)

# 五十 面向对象

面向对象

![73](./../../操作/4CPP/73.jpg)

# 五十一 属性

属性

![74](./../../操作/4CPP/74.jpg)

# 五十二 构造、析构

构造

析构

![75](./../../操作/4CPP/75.jpg)

# 五十三 thiscall

thiscall

![76](./../../操作/4CPP/76.jpg)

带参构造函数

![77](./../../操作/4CPP/77.jpg)

拷贝构造

![78](./../../操作/4CPP/78.jpg)

# 五十四 拷贝构造的调用时机

拷贝构造的调用时机

User u2 = u1;

User u3(u2);

类对象作参数传参

函数返回类对象

# 五十五 默认构造，析构，拷贝构造的机制

默认构造，析构，拷贝构造的机制

![79](./../../操作/4CPP/79.jpg)

# 五十六 浅拷贝

浅拷贝

![80](./../../操作/4CPP/80.jpg)

析构的时候会重复释放指针

两个对象指向同一块堆内存

深拷贝

![81](./../../操作/4CPP/81.jpg)

# 五十七 初始化列表

初始化列表

![82](./../../操作/4CPP/82.jpg)

# 五十八 嵌套类

嵌套类

![83](./../../操作/4CPP/83.jpg)

# 五十九 静态成员变量

静态成员变量

![84](./../../操作/4CPP/84.jpg)

静态成员变量必须初始化，且在类外部初始化。所有对象共享一个静态成员变量

# 六十 静态成员函数

静态成员函数只能访问静态成员变量

![85](./../../操作/4CPP/85.jpg)

# 六十一 空类占用一个字节

空类占用一个字节

![86](./../../操作/4CPP/86.jpg)

成员变量占对象内存

静态成员变量和成员函数不占对象内存

# 六十二 this指针

一个类，创建两个对象

分别调用成员函数。成员函数不占对象的内存，只有一份成员函数，怎么还能分别调用成员函数呢

this指针

![87](./../../操作/4CPP/87.jpg)

引用不能修改指针指向，可以修改指向的内容。不加const是因为可能有set函数修改对象的成员

# 六十三 const修饰类对象

常对象

const修饰类对象，成员变量是public权限

![88](./../../操作/4CPP/88.jpg)

可以访问成员变量，不能修改成员变量



mutable

![89](./../../操作/4CPP/89.jpg)

常对象不能调用成员函数

![90](./../../操作/4CPP/90.jpg)

常对象只能调用常函数

![91](./../../操作/4CPP/91.jpg)

常函数内部不能修改成员变量，除非成员变量加了mutable

![92](./../../操作/4CPP/92.jpg)

# 六十四 友元

友元，在类外部访问类的私有成员

全局函数做友元

![93](./../../操作/4CPP/93.jpg)

# 六十五 类做友元

类做友元

![94](./../../操作/4CPP/94.jpg)

# 六十六 类的成员函数做友元

类的成员函数做友元

![95](./../../操作/4CPP/95.jpg)

# 六十七 类内部的运算符重载函数

类内部的运算符重载函数。

![96](./../../操作/4CPP/96.jpg)

这里返回局部变量的值，是可以的。

不能返回局部变量的引用，跟指针一样。就算会调拷贝构造，调拷贝构造的时候，局部变量也已经被释放了

# 六十八 全局的运算符重载函数

全局的运算符重载函数。

![97](./../../操作/4CPP/97.jpg)

返回的局部变量的值

可以函数重载，可以多个参数

![98](./../../操作/4CPP/98.jpg)

# 六十九 重载<<

重载<<。只能用全局运算符重载函数

![99](./../../操作/4CPP/99.jpg)

# 七十 重载前++

运算符重载前++

![100](./../../操作/4CPP/100.jpg)

*this不是局部变量，所以可以返回

# 七十一 重载=

=运算符重载

![101](./../../操作/4CPP/101.jpg)

```c
User u2 = u1;// 类对象初始化，调拷贝构造
u2 = u1;// 类对象赋值，调=运算符重载
```

# 七十二 重载关系运算符

重载关系运算符

![102](./../../操作/4CPP/102.jpg)

# 七十三 继承

继承

![103](./../../操作/4CPP/103.jpg)

# 七十四 继承方式

public继承

![104](./../../操作/4CPP/104.jpg)

protected继承

![105](./../../操作/4CPP/105.jpg)

![106](./../../操作/4CPP/106.jpg)

会将public的成员变量变成protected的成员变量。类外部也不能访问了

但子类还能访问父类除了private的成员变量

private继承

![107](./../../操作/4CPP/107.jpg)

将父类public和protected都变成private。但子类还能访问父类除了private的成员变量

# 七十五 类对象的内存布局

类对象的内存布局

![108](./../../操作/4CPP/108.jpg)

也是在栈空间。跟const一样是编译器限制

![109](./../../操作/4CPP/109.jpg)

# 七十六 继承中的构造和析构

嵌套类的构造和析构

![110](./../../操作/4CPP/110.jpg)

继承中的构造和析构

![111](./../../操作/4CPP/111.jpg)

# 七十七 多层继承

多层继承

![112](./../../操作/4CPP/112.jpg)

# 七十八 多重继承

多重继承

![113](./../../操作/4CPP/113.jpg)

# 七十九 继承中的同名问题

继承中的同名问题

![114](./../../操作/4CPP/114.jpg)

![115](./../../操作/4CPP/115.jpg)

优先匹配自己类里的。没有才去找父类

# 八十 继承中，父子类都有同名的静态成员变量

继承中，父子类都有同名的静态成员变量

![116](./../../操作/4CPP/116.jpg)

![117](./../../操作/4CPP/117.jpg)

# 八十一 子类重写父类的成员函数

子类重写父类的成员函数

![118](./../../操作/4CPP/118.jpg)

字类转父类的指针或引用

![119](./../../操作/4CPP/119.jpg)

![120](./../../操作/4CPP/120.jpg)

# 八十二 虚表

虚表

![121](./../../操作/4CPP/121.jpg)

# 八十三 纯虚函数

纯虚函数

![122](./../../操作/4CPP/122.jpg)

字类必须重写父类的纯虚函数

# 八十四 虚析构

子类转父类的指针或引用。如果不写虚析构，释放的时候，调用的父类的析构

![123](./../../操作/4CPP/123.jpg)

虚析构

![124](./../../操作/4CPP/124.jpg)

# 八十五 纯虚析构

纯虚析构

![125](./../../操作/4CPP/125.jpg)

纯虚析构需要在抽象类外面实现一下

# 八十六 C++打开文件

打开文件。获取文件的基本信息

![126](./../../操作/4CPP/126.jpg)

# 八十七 C语言打开和关闭文件

打开和关闭文件，C语言的方式

![127](./../../操作/4CPP/127.jpg)

fclose之后，pFile里的内容没有清空，可以pFile = nullptr;

# 八十八 C语言文件操作

文件操作，C语言方式

![128](./../../操作/4CPP/128.jpg)

fread和fwrite的第三个参数的1是读/写几次

# 八十九 CPP读写文件

写文件，CPP方式

![129](./../../操作/4CPP/129.jpg)

读文件

![130](./../../操作/4CPP/130.jpg)

一行一行读文件

![131](./../../操作/4CPP/131.jpg)
